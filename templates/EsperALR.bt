//------------------------------------------------
//--- 010 Editor v11.0 Binary Template
//
//      File: Phantom Dust ALR Binary
//   Authors: UltimateBoboboFan713
//   Version: 1.0.0
//   Purpose: Stores mesh and/or texture data (?)
//  Category: Visual Assets
// File Mask: *.alr
//  ID Bytes: 11 00 00 00
//   History: 
//------------------------------------------------
struct File_ALR
{
    LittleEndian();
	struct Header 
	{
		int Magic<bgcolor=cGray>; // 11 00 00 00
		int Size<bgcolor=cGreen>;
		int Flags<bgcolor=cYellow>; // (?) Example from pc00a.alr: 52 00 07 00
		int WhitespaceEndAddress<bgcolor=cLtGray>;
		int InfoSectionsCount<bgcolor=cLtGray>;
		int Unk1<bgcolor=cLtRed>; // Maybe a reference to an offet really far into the file?
		double Pad;
		int OffsetArray[InfoSectionsCount]<bgcolor=cLtBlue>;
	} header;

	while (ReadDouble() != 0x00)
	{
		if (ReadByte() == 0x15 || ReadByte() == 0x16)
		{
			struct Block0x15 
			{
				int Magic<bgcolor=cLtGray>;
				int Size<bgcolor=cBlue>;
				int InfoSectionsCount<bgcolor=cLtGray>;
				struct InfoSection2
				{
				    int Flags2<bgcolor=cYellow>; // (?) Example from pc00a.alr: 0x01 00 04 00
				    int DataSec_Start<bgcolor=cGreen>;
				    int Unk<bgcolor=cLtRed>;
				    int Unk<bgcolor=cLtRed>;
				    int UnkZ<bgcolor=cLtRed>;
				    int StaticID<bgcolor=cPurple>;
				    int Unk<bgcolor=cLtRed>;
				} Subsection[InfoSectionsCount];
			} Subfile;
		}

        if (ReadByte() == 0x14)
		{
		    struct Block0x14
		    {
			    int Magic<bgcolor=cLtGray>; // 0D 00 00 00
			    int SectorSize<bgcolor=cBlue>;
                double Unk<bgcolor=cRed>;
                int Flags<bgcolor=cYellow>;
                int Unk<bgcolor=cRed>;
                local int DataSize = SectorSize - 24;
                char DataSection[DataSize]<bgcolor=cGreen>;
		    } Subfile;
        }

        if (ReadByte() == 0x13)
		{
			struct Block0x13
			{
				int Magic<bgcolor=cLtGray>; // 13 00 00 00
				int SectorSize<bgcolor=cBlue>;
				int Flags<bgcolor=cYellow>; // Example from eft0601.alr: 01 00 12 00
				int Flags<bgcolor=cYellow>;
				int Unk<bgcolor=cRed>;
				int UnkZero1<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 11 00 01 00
				char padding[28]; // (?)
				// 0x[SIZE-0x3A] padding
				// 0x3A = 58
				local int DataSize1 = SectorSize - 56;
				char DataSector[DataSize1]<bgcolor=cGreen>;
			} Subfile;
		}
		
        if (ReadByte() == 0xD)
		{
		    struct Block0xD
		    {
			int Magic<bgcolor=cLtGray>; // 0D 00 00 00
			int SectorSize<bgcolor=cBlue>;
            int Pad;
		    } Subfile;
        }

        if (ReadByte() == 3 || ReadByte() == 5)
		{
			struct Block0x3
			{
				int Magic<bgcolor=cLtGray>; // 03 00 00 00
				int Size<bgcolor=cBlue>;
				int Unk1<bgcolor=cRed>; // Seems to always be 00 00 20 42
				int Flags<bgcolor=cYellow>; // (?) Example from pc00a.alr: 06 00 08 00
				int Unk2<bgcolor=cRed>;
				int Unk3<bgcolor=cRed>; // UNK2 and UNK3 sometimes match each other in value. When they don't, UNK3 is always 0
				int UnkZero1<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // Example from pc00a.alr: 00 02 0C 00
		
				// 0x[SIZE-0x24] DATA
				// 0x24 = 36
				local int DataSize = Size - 32;
				char DataSector[DataSize]<bgcolor=cGreen>;
			} Subfile;
		}

		if (ReadByte() == 0x10)
		{
			struct Block0x10
			{
				int Magic<bgcolor=cLtGray>; // 10 00 00 00
				int SectorSize<bgcolor=cBlue>;
				int DDS_Num<bgcolor=cPurple>;
				int TGA_Num<bgcolor=cPurple>;
                char Name[16]<bgcolor=cYellow>;

                struct DDS_Names
                {
                    char DDSName[16]<bgcolor=cYellow>;
                    char UnkPad0[16]<bgcolor=cRed>;
                } DDS[DDS_Num];

                char DDS_Unk [DDS_Num * 20]<bgcolor=cLtRed>;

                struct TGA_Names
                {
                    char TGAName[32]<bgcolor=cYellow>;
                    char UnkPad[28]<bgcolor=cRed>;
                } TGA[TGA_Num];
			} Subfile;
		}

        if (ReadByte() == 2)
		{
			struct Block0x2
			{
				int Magic<bgcolor=cLtGray>; // 01 00 00 00
				int SectorSize<bgcolor=cBlue>;
				int Flags<bgcolor=cYellow>; // Example from eft0601.alr: 01 00 12 00
				int Unk<bgcolor=cRed>;
				int Unk<bgcolor=cRed>;
				int UnkZero1<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 11 00 01 00
				int Unk<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 00 11 01 00
                int Unk<bgcolor=cRed>;
                int Unk<bgcolor=cRed>;
                int Unk<bgcolor=cRed>;
				char padding[12];
				local int DataSize1 = SectorSize - 60;
                char datablock[DataSize1]<bgcolor=cGreen>;
			} Subfile;
		}        

		if (ReadByte() == 1)
		{
			struct Block0x1
			{
				int Magic<bgcolor=cLtGray>; // 01 00 00 00
				int SectorSize<bgcolor=cBlue>;
				int Flags<bgcolor=cYellow>; // Example from eft0601.alr: 01 00 12 00
				int Unk1<bgcolor=cRed>;
				int Unk2<bgcolor=cRed>;
				int UnkZero1<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 11 00 01 00
				int Unk3<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 00 11 01 00
				int Unk4<bgcolor=cRed>;
                char padding[18]; // (?)
				// 0x[SIZE-0x3A] padding
				// 0x40 = 64
				local int DataSize1 = SectorSize - 58;
				char DataSector[DataSize1]<bgcolor=cGreen>;
			} Subfile;
		}
        
        if (ReadByte() == 0x00)
		{
		    struct Block0x0
		    {
			    int Magic<bgcolor=cLtGray>; // 00 00 00 00
			    int SectorSize<bgcolor=cBlue>;
                if (SectorSize > 8)
                {
                    local int DataSize1 = SectorSize - 8;
                    char DataSector[DataSize1]<bgcolor=cGreen>;
                }
		    } Subfile;
        }

        if (ReadByte() != 0x00 && ReadByte() != 0x01 && ReadByte() != 0x02 && ReadByte() != 0x03 && ReadByte() !=0x05 && ReadByte() != 0x0D && ReadByte() && ReadByte() != 0x0D && ReadByte() != 0x10 && ReadByte() != 0x13 && ReadByte() != 0x14 && ReadByte() != 0x15 && ReadByte() != 0x16)
        {
            break;
        }
	}
    char Whitespace[header.WhitespaceEndAddress - (FTell())]<bgcolor=cGray>;
} file;