//------------------------------------------------
//--- 010 Editor v11.0 Binary Template
//
//      File: Phantom Dust ALR Binary
//   Authors: UltimateBoboboFan713
//   Version: 1.0.0
//   Purpose: Stores mesh and/or texture data (?)
//  Category: Visual Assets
// File Mask: *.alr
//  ID Bytes: 11 00 00 00
//   History: 
//------------------------------------------------
struct File_ALR
{
    LittleEndian();
	struct Header 
	{
		int Magic<bgcolor=cGray>; // 11 00 00 00
		int Size<bgcolor=cGreen>;
		int Flags<bgcolor=cYellow>; // (?) Example from pc00a.alr: 52 00 07 00
		int DataSectionInit<bgcolor=cLtGray>;
		int InfoSectionsCount<bgcolor=cLtGray>;
		int Unk1<bgcolor=cLtRed>; // Maybe a reference to an offet really far into the file?
		double Pad;
		int OffsetArray[InfoSectionsCount]<bgcolor=cLtBlue>;
	} header;
	local int CurrentHeader = ReadByte();
	while (ReadDouble() != 0x00)
	{
        CurrentHeader = ReadByte();
		if (ReadByte() == 21 || ReadByte() == 22)
		{
			struct Block0x15 
			{
				int Magic<bgcolor=cLtGray>;
				int Size<bgcolor=cBlue>;
				int InfoSectionsCount<bgcolor=cLtGray>;
				struct InfoSection2
				{
					//Repeat [NUM_INFO_SECTIONS] times
					local int InfoSecNum = 0;
					while (InfoSecNum < InfoSectionsCount)
					{
						int Flags2<bgcolor=cYellow>; // (?) Example from pc00a.alr: 0x01 00 04 00
						int DataSec_Start<bgcolor=cGreen>;
						int UnkZero<bgcolor=cLtRed>;
						int Unk<bgcolor=cLtRed>;
						int UnkZero<bgcolor=cLtRed>;
						int Unk<bgcolor=cLtRed>;
						int Unk<bgcolor=cLtRed>;
						InfoSecNum++;
					}
				} Subsection;
			} Subfile;
		}

        if (ReadByte() == 0x14)
		{
		    struct Block0x14
		    {
			    int Magic<bgcolor=cLtGray>; // 0D 00 00 00
			    int SectorSize<bgcolor=cBlue>;
                double Unk<bgcolor=cRed>;
                int Flags<bgcolor=cYellow>;
                int Unk<bgcolor=cRed>;
                local int DataSize = SectorSize - 24;
                char DataSection[DataSize]<bgcolor=cGreen>;
		    } Subfile;
        }

        if (ReadByte() == 0x13)
		{
			struct Block0x13
			{
				int Magic<bgcolor=cLtGray>; // 01 00 00 00
				int SectorSize<bgcolor=cBlue>;
				int Flags<bgcolor=cYellow>; // Example from eft0601.alr: 01 00 12 00
				int Flags<bgcolor=cYellow>;
				int Unk<bgcolor=cRed>;
				int UnkZero1<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 11 00 01 00
				char padding[28]; // (?)
				// 0x[SIZE-0x3A] padding
				// 0x3A = 58
				local int DataSize1 = SectorSize - 56;
				char DataSector[DataSize1]<bgcolor=cGreen>;
			} Subfile;
		}
		
        if (ReadByte() == 0xD)
		{
		    struct Block0xD
		    {
			int Magic<bgcolor=cLtGray>; // 0D 00 00 00
			int SectorSize<bgcolor=cBlue>;
            int Pad;
		    } Subfile;
        }

        if (ReadByte() == 3 || ReadByte() == 5)
		{
			struct Block0x3
			{
				int Magic<bgcolor=cLtGray>; // 03 00 00 00
				int Size<bgcolor=cBlue>;
				int Unk1<bgcolor=cRed>; // Seems to always be 00 00 20 42
				int Flags<bgcolor=cYellow>; // (?) Example from pc00a.alr: 06 00 08 00
				int Unk2<bgcolor=cRed>;
				int Unk3<bgcolor=cRed>; // UNK2 and UNK3 sometimes match each other in value. When they don't, UNK3 is always 0
				int UnkZero1<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // Example from pc00a.alr: 00 02 0C 00
				int UnkZero2<bgcolor=cRed>;
		
				// 0x[SIZE-0x24] DATA
				// 0x24 = 36
				local int DataSize = Size - 36;
				char DataSector[DataSize]<bgcolor=cGreen>;
			} Subfile;
		}
		
        if (ReadByte() == 2)
		{
			struct Block0x2
			{
				int Magic<bgcolor=cLtGray>; // 01 00 00 00
				int SectorSize<bgcolor=cBlue>;
				int Flags<bgcolor=cYellow>; // Example from eft0601.alr: 01 00 12 00
				int Unk<bgcolor=cRed>;
				int Unk<bgcolor=cRed>;
				int UnkZero1<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 11 00 01 00
				int Unk<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 00 11 01 00
                int Unk<bgcolor=cRed>;
                int Unk<bgcolor=cRed>;
                int Unk<bgcolor=cRed>;
				char padding[10]; // (?)
				// 0x[SIZE-0x3A] padding
				// 0x3A = 58
				local int DataSize1 = SectorSize - 58;
				char DataSector[DataSize1]<bgcolor=cGreen>;
			} Subfile;
		}        

		if (ReadByte() == 1)
		{
			struct Block0x1
			{
				int Magic<bgcolor=cLtGray>; // 01 00 00 00
				int SectorSize<bgcolor=cBlue>;
				int Flags<bgcolor=cYellow>; // Example from eft0601.alr: 01 00 12 00
				int Unk1<bgcolor=cRed>;
				int Unk2<bgcolor=cRed>;
				int UnkZero1<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 11 00 01 00
				int Unk3<bgcolor=cRed>;
				int Flags<bgcolor=cYellow>; // (?) Example from eft0601.alr: 00 11 01 00
				int Unk4<bgcolor=cRed>;
                char padding[18]; // (?)
				// 0x[SIZE-0x3A] padding
				// 0x40 = 64
				local int DataSize1 = SectorSize - 58;
				char DataSector[DataSize1]<bgcolor=cGreen>;
			} Subfile;
		}
        
        if (ReadByte() == 0x00 && ReadDouble() != 0x0000000000000000)
		{
		    struct Block0x0
		    {
			    int Magic<bgcolor=cLtGray>; // 00 00 00 00
			    int SectorSize<bgcolor=cBlue>;
                if (SectorSize > 8)
                {
                    local int DataSize1 = SectorSize - 8;
                    char DataSector[DataSize1]<bgcolor=cGreen>;
                }
		    } Subfile;
        }
        if (ReadByte() != 0x00 && ReadByte() != 0x01 && ReadByte() != 0x02 && ReadByte() != 0x03 && ReadByte() != 05 && ReadByte() != 0x0D && ReadByte() != 0x13 && ReadByte() != 0x14 && ReadByte() != 0x15 && ReadByte() != 0x16)
        {
            break;
        }
	}
} file;